name: 系统维护和清理

on:
  # 每天凌晨2点执行维护任务
  schedule:
    - cron: '0 2 * * *'
  
  # 手动触发
  workflow_dispatch:
    inputs:
      cleanup_type:
        description: '清理类型'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - images
          - logs
          - backups
          - cache
      force_cleanup:
        description: '强制清理 (删除所有旧数据)'
        required: false
        default: false
        type: boolean

env:
  ACR_REGISTRY: registry.cn-hangzhou.aliyuncs.com
  ACR_NAMESPACE: guessing-pen

jobs:
  # 清理Docker镜像
  cleanup-images:
    name: 清理Docker镜像
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || inputs.cleanup_type == 'all' || inputs.cleanup_type == 'images'
    
    steps:
      - name: 清理GitHub Actions缓存
        uses: actions/github-script@v7
        with:
          script: |
            const caches = await github.rest.actions.getActionsCaches({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            // 保留最近10个缓存，删除其他的
            const cachesToDelete = caches.data.actions_caches
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
              .slice(10);
            
            for (const cache of cachesToDelete) {
              try {
                await github.rest.actions.deleteActionsCacheById({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  cache_id: cache.id,
                });
                console.log(`已删除缓存: ${cache.key}`);
              } catch (error) {
                console.log(`删除缓存失败: ${cache.key} - ${error.message}`);
              }
            }
            
            console.log(`清理完成，删除了 ${cachesToDelete.length} 个旧缓存`);

  # 服务器维护
  server-maintenance:
    name: 服务器维护
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || inputs.cleanup_type == 'all' || inputs.cleanup_type != 'cache'
    
    strategy:
      matrix:
        environment: [production]
        # 如果有staging环境，可以添加: [production, staging]
    
    steps:
      - name: 服务器清理和维护
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ matrix.environment == 'production' && secrets.PROD_SERVER_HOST || secrets.STAGING_SERVER_HOST }}
          username: ${{ matrix.environment == 'production' && secrets.PROD_SERVER_USER || secrets.STAGING_SERVER_USER }}
          key: ${{ matrix.environment == 'production' && secrets.PROD_SERVER_SSH_KEY || secrets.STAGING_SERVER_SSH_KEY }}
          port: ${{ matrix.environment == 'production' && secrets.PROD_SERVER_PORT || secrets.STAGING_SERVER_PORT || 22 }}
          script: |
            set -e
            
            # 设置变量
            CLEANUP_TYPE="${{ inputs.cleanup_type || 'all' }}"
            FORCE_CLEANUP="${{ inputs.force_cleanup || 'false' }}"
            ENVIRONMENT="${{ matrix.environment }}"
            
            if [[ "$ENVIRONMENT" == "production" ]]; then
              DEPLOY_PATH="/opt/guessing-pen"
            else
              DEPLOY_PATH="/opt/guessing-pen-staging"
            fi
            
            # 创建维护日志
            MAINTENANCE_LOG="${DEPLOY_PATH}/logs/maintenance-$(date +%Y%m%d-%H%M%S).log"
            mkdir -p "${DEPLOY_PATH}/logs"
            
            # 日志函数
            log_info() {
              echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$MAINTENANCE_LOG"
            }
            
            log_success() {
              echo "[SUCCESS] $(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$MAINTENANCE_LOG"
            }
            
            log_warning() {
              echo "[WARNING] $(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$MAINTENANCE_LOG"
            }
            
            # 清理Docker镜像
            cleanup_docker_images() {
              log_info "🧹 清理Docker镜像..."
              
              # 清理未使用的镜像
              docker image prune -f
              
              # 清理旧版本镜像（保留最近5个版本）
              local frontend_images=$(docker images "${{ env.ACR_REGISTRY }}/${{ env.ACR_NAMESPACE }}/guessing-pen-frontend" --format "{{.Tag}}" | grep -v latest | sort -V)
              local api_images=$(docker images "${{ env.ACR_REGISTRY }}/${{ env.ACR_NAMESPACE }}/guessing-pen-api" --format "{{.Tag}}" | grep -v latest | sort -V)
              
              # 删除旧的前端镜像
              if [[ "$FORCE_CLEANUP" == "true" ]]; then
                local keep_count=3
              else
                local keep_count=5
              fi
              
              echo "$frontend_images" | head -n -$keep_count | while read tag; do
                if [[ -n "$tag" && "$tag" != "latest" ]]; then
                  log_info "删除旧前端镜像: $tag"
                  docker rmi "${{ env.ACR_REGISTRY }}/${{ env.ACR_NAMESPACE }}/guessing-pen-frontend:$tag" || true
                fi
              done
              
              echo "$api_images" | head -n -$keep_count | while read tag; do
                if [[ -n "$tag" && "$tag" != "latest" ]]; then
                  log_info "删除旧API镜像: $tag"
                  docker rmi "${{ env.ACR_REGISTRY }}/${{ env.ACR_NAMESPACE }}/guessing-pen-api:$tag" || true
                fi
              done
              
              # 清理悬空镜像
              docker image prune -f
              
              log_success "Docker镜像清理完成"
            }
            
            # 清理日志文件
            cleanup_logs() {
              log_info "🧹 清理日志文件..."
              
              cd "$DEPLOY_PATH"
              
              # 清理应用日志（保留最近30天）
              if [[ "$FORCE_CLEANUP" == "true" ]]; then
                local keep_days=7
              else
                local keep_days=30
              fi
              
              find logs/ -name "*.log" -type f -mtime +$keep_days -delete 2>/dev/null || true
              
              # 清理Docker容器日志
              docker system prune -f --volumes
              
              # 清理系统日志（如果权限允许）
              if command -v journalctl &> /dev/null; then
                sudo journalctl --vacuum-time=30d 2>/dev/null || log_warning "无法清理系统日志，权限不足"
              fi
              
              log_success "日志文件清理完成"
            }
            
            # 清理备份文件
            cleanup_backups() {
              log_info "🧹 清理备份文件..."
              
              cd "$DEPLOY_PATH"
              
              # 清理旧备份（保留最近20个）
              if [[ "$FORCE_CLEANUP" == "true" ]]; then
                local keep_count=10
              else
                local keep_count=20
              fi
              
              # 按时间排序，删除旧备份
              ls -t backups/backup-*.json 2>/dev/null | tail -n +$((keep_count + 1)) | xargs -r rm -f
              
              # 清理超过90天的备份
              find backups/ -name "backup-*.json" -type f -mtime +90 -delete 2>/dev/null || true
              
              log_success "备份文件清理完成"
            }
            
            # 系统资源检查
            system_health_check() {
              log_info "🏥 系统健康检查..."
              
              # 检查磁盘空间
              local disk_usage=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
              log_info "磁盘使用率: ${disk_usage}%"
              
              if [[ $disk_usage -gt 80 ]]; then
                log_warning "⚠️ 磁盘使用率过高: ${disk_usage}%"
              fi
              
              # 检查内存使用
              local memory_usage=$(free | awk 'NR==2{printf "%.2f", $3*100/$2}')
              log_info "内存使用率: ${memory_usage}%"
              
              # 检查Docker服务状态
              if systemctl is-active --quiet docker; then
                log_info "✅ Docker服务正常运行"
              else
                log_warning "❌ Docker服务异常"
              fi
              
              # 检查应用容器状态
              cd "$DEPLOY_PATH"
              local container_status=$(docker-compose -f docker-compose.prod.yml ps --format json 2>/dev/null || echo "[]")
              log_info "容器状态: $container_status"
              
              # 检查服务可用性
              if curl -f -s http://localhost:80/health > /dev/null 2>&1; then
                log_info "✅ 前端服务正常"
              else
                log_warning "❌ 前端服务异常"
              fi
              
              if curl -f -s http://localhost:3005/health > /dev/null 2>&1; then
                log_info "✅ API服务正常"
              else
                log_warning "❌ API服务异常"
              fi
              
              log_success "系统健康检查完成"
            }
            
            # 生成维护报告
            generate_maintenance_report() {
              log_info "📊 生成维护报告..."
              
              local report_file="${DEPLOY_PATH}/maintenance-report-$(date +%Y%m%d).json"
              
              # 收集系统信息
              local disk_usage=$(df -h / | awk 'NR==2 {print $5}')
              local memory_usage=$(free | awk 'NR==2{printf "%.2f%%", $3*100/$2}')
              local docker_images_count=$(docker images | wc -l)
              local containers_count=$(docker ps -a | wc -l)
              
              # 生成报告
              cat > "$report_file" << EOF
            {
              "timestamp": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",
              "environment": "$ENVIRONMENT",
              "cleanup_type": "$CLEANUP_TYPE",
              "force_cleanup": "$FORCE_CLEANUP",
              "system_info": {
                "disk_usage": "$disk_usage",
                "memory_usage": "$memory_usage",
                "docker_images_count": $docker_images_count,
                "containers_count": $containers_count
              },
              "maintenance_log": "$MAINTENANCE_LOG"
            }
            EOF
              
              log_success "维护报告生成完成: $report_file"
            }
            
            # 主执行逻辑
            log_info "🔧 开始系统维护 - 环境: $ENVIRONMENT"
            log_info "清理类型: $CLEANUP_TYPE"
            log_info "强制清理: $FORCE_CLEANUP"
            
            # 执行系统健康检查
            system_health_check
            
            # 根据清理类型执行相应操作
            case "$CLEANUP_TYPE" in
              "all")
                cleanup_docker_images
                cleanup_logs
                cleanup_backups
                ;;
              "images")
                cleanup_docker_images
                ;;
              "logs")
                cleanup_logs
                ;;
              "backups")
                cleanup_backups
                ;;
            esac
            
            # 再次执行健康检查
            system_health_check
            
            # 生成维护报告
            generate_maintenance_report
            
            log_success "🎉 系统维护完成！"

  # 发送维护报告
  maintenance-report:
    name: 维护报告
    runs-on: ubuntu-latest
    needs: [cleanup-images, server-maintenance]
    if: always()
    
    steps:
      - name: 生成维护摘要
        run: |
          echo "📊 **系统维护报告**" > maintenance_summary.md
          echo "" >> maintenance_summary.md
          echo "**时间**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> maintenance_summary.md
          echo "**触发方式**: ${{ github.event_name }}" >> maintenance_summary.md
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "**清理类型**: ${{ inputs.cleanup_type }}" >> maintenance_summary.md
            echo "**强制清理**: ${{ inputs.force_cleanup }}" >> maintenance_summary.md
          fi
          
          echo "" >> maintenance_summary.md
          echo "**执行结果**:" >> maintenance_summary.md
          
          # 检查各个job的状态
          if [[ "${{ needs.cleanup-images.result }}" == "success" ]]; then
            echo "- ✅ GitHub缓存清理: 成功" >> maintenance_summary.md
          elif [[ "${{ needs.cleanup-images.result }}" == "failure" ]]; then
            echo "- ❌ GitHub缓存清理: 失败" >> maintenance_summary.md
          elif [[ "${{ needs.cleanup-images.result }}" == "skipped" ]]; then
            echo "- ⏭️ GitHub缓存清理: 跳过" >> maintenance_summary.md
          fi
          
          if [[ "${{ needs.server-maintenance.result }}" == "success" ]]; then
            echo "- ✅ 服务器维护: 成功" >> maintenance_summary.md
          elif [[ "${{ needs.server-maintenance.result }}" == "failure" ]]; then
            echo "- ❌ 服务器维护: 失败" >> maintenance_summary.md
          elif [[ "${{ needs.server-maintenance.result }}" == "skipped" ]]; then
            echo "- ⏭️ 服务器维护: 跳过" >> maintenance_summary.md
          fi
          
          echo "" >> maintenance_summary.md
          echo "**查看详情**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> maintenance_summary.md
          
          # 输出摘要
          cat maintenance_summary.md
      
      - name: 发送维护通知
        if: github.event_name == 'schedule' || inputs.cleanup_type == 'all'
        run: |
          # 读取维护摘要
          SUMMARY=$(cat maintenance_summary.md)
          
          echo "维护通知: $SUMMARY"
          
          # 这里可以集成实际的通知服务
          # curl -X POST -H 'Content-Type: application/json' \
          #   -d "{\"text\": \"$SUMMARY\"}" \
          #   "${{ secrets.WEBHOOK_URL }}"